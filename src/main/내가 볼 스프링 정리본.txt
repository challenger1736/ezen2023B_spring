====================================Spring==========================================

1. 개발환경 : JDK17, 인텔리제이 무료버전
2. 프로젝트 생성
        1. Project : Gradle - Groovy : (각종 외부) 라이브러리 들을 자동으로 설치/관리 시스템
        2. Language : Java
        3. Spring Boot : 3.~ 이상
        4. Metadata
            Group : com
            Artifact : ~~
            Description : 설명

            Packaging : Jar
            Java : 17

        5. Dependencies
            1. Spring Web
            2. MySQL Driver
            3. Lombok
            4. Mustache

3. 인텔리제이에서 프로젝트 열기
        1. 파일 -> 열기 -> 파일이름 열기
        2. SpringMvcTest1Application 클래스 내 main함수 실행
        3. 브라우저에서 http://localhost:8080 접속

====================================================================================

IOC 제어역전, DI 의존성 주입

IOC : 프레임워크나 컨테이너가 애플리케이션의 제어를 가져가고 애플리케이션 코드는 프레임워크에 의해 호출됩니다.
      스프링에서 IOC는 주로 스프링 컨테이너에 의해 구현됩니다. 스프링 컨테이너는 객체의 생성, 관리, 라이프사이클을 관리하고 애플리케이션의 제어 흐름을 가져갑니다.

DI :  스프링에서 DI는 주로 스프링 컨테이너가 관리하는 빈(bean) 객체들 간의 의존성을 주입하는 것을 의미합니다.
      어노테이션 기반의 설정을 통해 스프링은 객체 간의 의존성을 해결하고 필요한 객체를 주입합니다.

====================================================================================
        @SpringBootApplication에 관하여.

@SpringBootApplication이 실행 되면
        컴포넌트 스캔 (Component Scan)[의존성 주입],
        내장 서버 시작 (Embedded Server Start),

SpringApplication.run(AppStart.class);

        SpringApplication에 있는 정적 메소드 run()이 실행되어 그 해당 클래스를 실행하게 해줌

====================================================================================
        @Controller와 @RestController의 차이

@Controller: 기본적으로는 [뷰(View)]를 반환합니다.
주로 JSP, Thymeleaf 등과 같은 템플릿 엔진을 통해 HTML을 생성하여 클라이언트에게 전달합니다.

@RestController: 기본적으로는 HTTP 응답 본문에 직접 [데이터] 객체를 반환합니다.
스프링은 반환된 객체를 JSON 또는 XML 형식으로 변환하여 클라이언트에게 전달합니다.
====================================================================================
★이걸 통해 할 수 있는 것은 무엇이 있을까? AJAX관련 공부를 좀 더 해야할 것 같다.★
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
머스테치 - 머스테치만 주고 받기 가능       [서버 사이드 랜더링]
          >>정보(데이터)만 주고 받기가 불가능.
                     행위때 마다 화면 요청
                     - 최초 실행은 빠름 but 화면전환 계속 됨 ( 부분요청 새로고침O)
          - 리턴 : 머스테치

AJAX(JQUERY) 데이터 주고받기           [클라이언트 사이드 랜더링]REACT
            - 데이터만 주고 받기 O      행위할 때마다 부분적 요청.
                     - 최초는 느림 (부분 요청 새로고침X)

====================================================================================
        @~~Mapping(URL주소)에 관한 이해

@PostMapping(URL주소) :  클라이언트로부터의 POST 요청을 처리, 새로운 데이터를 생성할 때 사용됩니다.
@GetMapping(URL주소) : 클라이언트로부터의 GET 요청을 처리, 데이터를 조회하거나 검색할 때 사용됩니다.
@PutMapping(URL주소) : 클라이언트로부터의 PUT 요청을 처리, 기존 데이터를 업데이트할 때 사용됩니다.
@DeleteMapping(URL주소) : 클라이언트로부터의 DELETE 요청을 처리, 데이터를 삭제할 때 사용됩니다.

====================================================================================

        @Component 빈(객체)만들고 @AutoWired TodoDao todoDao; 연결하기

====================================================================================
        List<E> list = new ArrayList<>(); 과 ArrayList<E> list = new ArrayList<>();의 차이.

List는 외부에서 부를 때 List로 불러야하므로 다른 구현체로의 전환이 쉽다.
일반적으로 인터페이스로 구현체를 만드는 것이 더 좋다고 여겨진다.

            List<> list = new ArrayList<>();
                List<> list = new Vector<>(); 가능

            ArrayList<> list = new ArrayList<>();
                    List<> list = new Vector<>(); 불가능 (형제)

====================================================================================

for문에 관한 정의

순회
        일반for문
        향상된for문. for(타입 타입변수명 : 리스트명){실행문;}
        리스트.forEach(반복변수명(자동으로 리스트의 객체로 들어감) -> 실행문or{실행문; 실행문;})

==================================================================================== 질문 1 =====

   Iterator<String> rs = set.iterator(); // Iterator뜻은 반복자, 반복요소 쓰려고 부르는 인터페이스
   System.out.println("rs : "+rs); // 불러보면 hashMap 이다. 즉 순서가 없는 배열을 만들어서 불러 내오는 느낌이네.
   while(!rs.next().isEmpty()){ //이거 안되네 신기하네, !=null도 마찬가지로 안됨. Gradle 9.0과 호환되지 않는다고 하는데, 이유를 모르겠음.
           System.out.println("rs.next()로 와일문 : " + rs.next());
       }


================== SQL 에 옮겨 적을 내용 ====================

조건절의 작성 순서
select (distinct:중복제거) 필드명 from 테이블명 where 조건절 order by 정렬기준 asc/desc(역순) limit( 볼 레코드 수 or 시작인덱스, 볼 레코드 수 )


====================================================================================
뷰 템플릿에 관한 구조

------------------------------------------------------------------------------------
@Controller

URL이 켜지면 그 함수가 실행되는 구조
(넘길 값이 있으면 Model model)모델 인터페이스를 해줘야 addAttribute("키명", 값)으로 넘길 수 있음.

함수에서 URL 재 요청(리턴 값) : return "redirect:URL_주소"

@GetMapping("/articles/{id}") 이런 주소에 {} 중괄호 하나 넣는건
@PathVariable을 쓰겠다는 의미, 이건 또 그걸 매개변수로 받는 함수를 실행하겠다는 의미

------------------------------------------------------------------------------------

머스테치에 관해 / 머스테치를 리턴하려면 String 이어야한다.
templates안의 주소 머스테치가 켜진다. 앞에 / 안쓰고 !

머스테치 문법
       {{변수명}} // 받는 값
       {{>파일경로}} // 받는 경로

<form action = (localhost:8080생략)/URL주소 method="get/post/set/delete">
</form>
이 폼이 실행되면 폼안의 있는 것들을 DTO에 실어서 보내거나 할 수 있다.
그건 <input>이나 여러가지의 name들과 DTO의 필드명이 같을 때 가능하다.

edit는 주소는 id를 받아야만 그 해당 id가 켜지므로 {id}를 써야함을 알 수 있으나,
결국 로직 처리하고 나오는 건 같으므로 뷰 템플릿은 하나만 있으면 되므로
articles/edit 하나만 return하면 된다.



====================================================================================

====================================================================================


처리된 데이터를 뷰 템플릿으로 보내려면 Model model,
or @PathVariable은 URL에서 받아온 {id}등을 값으로 써서 데이터 처리하려고 쓰는 것.

반대로

받아서 쓰는 건 필드명 같게 매개변수에 DTO로 보내기.


====================================================================================


처리된 데이터를 뷰 템플릿으로 보내려면 Model model,
or @PathVariable은 URL에서 받아온 {id}등을 값으로 써서 데이터 처리하려고 쓰는 것.

반대로

받아서 쓰는 건 필드명 같게 매개변수에 DTO로 보내기.