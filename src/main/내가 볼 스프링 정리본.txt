====================================Spring==========================================

1. 개발환경 : JDK17, 인텔리제이 무료버전
2. 프로젝트 생성
        1. Project : Gradle - Groovy : (각종 외부) 라이브러리 들을 자동으로 설치/관리 시스템
        2. Language : Java
        3. Spring Boot : 3.~ 이상
        4. Metadata
            Group : com
            Artifact : ~~
            Description : 설명

            Packaging : Jar
            Java : 17

        5. Dependencies
            1. Spring Web
            2. MySQL Driver
            3. Lombok
            4. Mustache

3. 인텔리제이에서 프로젝트 열기
        1. 파일 -> 열기 -> 파일이름 열기
        2. SpringMvcTest1Application 클래스 내 main함수 실행
        3. 브라우저에서 http://localhost:8080 접속

====================================================================================

IOC 제어역전, DI 의존성 주입

IOC : 프레임워크나 컨테이너가 애플리케이션의 제어를 가져가고 애플리케이션 코드는 프레임워크에 의해 호출됩니다.
      스프링에서 IOC는 주로 스프링 컨테이너에 의해 구현됩니다. 스프링 컨테이너는 객체의 생성, 관리, 라이프사이클을 관리하고 애플리케이션의 제어 흐름을 가져갑니다.

DI :  스프링에서 DI는 주로 스프링 컨테이너가 관리하는 빈(bean) 객체들 간의 의존성을 주입하는 것을 의미합니다.
      어노테이션 기반의 설정을 통해 스프링은 객체 간의 의존성을 해결하고 필요한 객체를 주입합니다.

====================================================================================
        @SpringBootApplication에 관하여.

@SpringBootApplication이 실행 되면
        컴포넌트 스캔 (Component Scan)[의존성 주입],
        내장 서버 시작 (Embedded Server Start),

SpringApplication.run(AppStart.class);

        SpringApplication에 있는 정적 메소드 run()이 실행되어 그 해당 클래스를 실행하게 해줌

====================================================================================
        @Controller와 @RestController의 차이

@Controller: 기본적으로는 [뷰(View)]를 반환합니다.
주로 JSP, Thymeleaf 등과 같은 템플릿 엔진을 통해 HTML을 생성하여 클라이언트에게 전달합니다.

@RestController: 기본적으로는 HTTP 응답 본문에 직접 [데이터] 객체를 반환합니다.
스프링은 반환된 객체를 JSON 또는 XML 형식으로 변환하여 클라이언트에게 전달합니다.
====================================================================================
★이걸 통해 할 수 있는 것은 무엇이 있을까? AJAX관련 공부를 좀 더 해야할 것 같다.★
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
머스테치 - 머스테치만 주고 받기 가능       [서버 사이드 랜더링]
          >>정보(데이터)만 주고 받기가 불가능.
                     행위때 마다 화면 요청
                     - 최초 실행은 빠름 but 화면전환 계속 됨 ( 부분요청 새로고침O)
          - 리턴 : 머스테치(거기에 Model model(addAttribute된.)을 포함함)

AJAX(JQUERY) 데이터 주고받기           [클라이언트 사이드 랜더링]REACT
            - 데이터만 주고 받기 O      행위할 때마다 부분적 요청.
                     - 최초는 느림 (부분 요청 새로고침X)

====================================================================================
        @~~Mapping(URL주소)에 관한 이해

@PostMapping(URL주소) :  클라이언트로부터의 POST 요청을 처리, 새로운 데이터를 생성할 때 사용됩니다.
@GetMapping(URL주소) : 클라이언트로부터의 GET 요청을 처리, 데이터를 조회하거나 검색할 때 사용됩니다.
@PutMapping(URL주소) : 클라이언트로부터의 PUT 요청을 처리, 기존 데이터를 업데이트할 때 사용됩니다.
@DeleteMapping(URL주소) : 클라이언트로부터의 DELETE 요청을 처리, 데이터를 삭제할 때 사용됩니다.

====================================================================================

        @Component 빈(객체)만들고 @AutoWired TodoDao todoDao; 연결하기

====================================================================================

for문에 관한 정의

순회
        일반for문
        향상된for문. for(타입 타입변수명 : 리스트명){실행문;}
        리스트.forEach(반복변수명(자동으로 리스트의 객체로 들어감) -> 실행문or{실행문; 실행문;})

==================================================================================== 질문 1 =====

   Iterator<String> rs = set.iterator(); // Iterator뜻은 반복자, 반복요소 쓰려고 부르는 인터페이스
   System.out.println("rs : "+rs); // 불러보면 hashMap 이다. 즉 순서가 없는 배열을 만들어서 불러 내오는 느낌이네.
   while(!rs.next().isEmpty()){ //이거 안되네 신기하네, !=null도 마찬가지로 안됨. Gradle 9.0과 호환되지 않는다고 하는데, 이유를 모르겠음.
           System.out.println("rs.next()로 와일문 : " + rs.next());
       }


================== SQL 에 옮겨 적을 내용 ====================

조건절의 작성 순서
select (distinct:중복제거) 필드명 from 테이블명 where 조건절 order by 정렬기준 asc/desc(역순) limit( 볼 레코드 수 or 시작인덱스, 볼 레코드 수 )